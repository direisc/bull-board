/// <reference types="node" />
import { ChildProcess } from 'child_process';
import { Cluster } from 'ioredis';
import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { RedisOptions as RedisOptions_2 } from 'ioredis';

export declare interface AdvancedOptions {
    /**
     * A set of custom backoff strategies keyed by name.
     */
    backoffStrategies?: {};
}

export declare const AdvancedOptionsDefaults: AdvancedOptions;

export declare type BackoffFunction = (attemptsMade?: number, err?: Error, job?: Job) => number;

/**
 * Settings for backing off failed jobs.
 *
 * @see {@link https://docs.bullmq.io/guide/retrying-failing-jobs}
 */
export declare interface BackoffOptions {
    /**
     * Name of the backoff strategy.
     */
    type: string;
    /**
     * Delay in milliseconds.
     */
    delay?: number;
}

export declare class Backoffs {
    static builtinStrategies: BuiltInStrategies;
    static normalize(backoff: number | BackoffOptions): BackoffOptions;
    static calculate(backoff: BackoffOptions, attemptsMade: number, customStrategies: Strategies, err: Error, job: Job): number;
}

declare interface BuiltInStrategies {
    [index: string]: (delay: number) => BackoffFunction;
}

export declare type BulkJobOptions = Omit<JobsOptions, 'repeat'>;

export declare class ChildPool {
    retained: {
        [key: number]: ChildProcessExt;
    };
    free: {
        [key: string]: ChildProcessExt[];
    };
    retain(processFile: string): Promise<ChildProcessExt>;
    release(child: ChildProcessExt): void;
    remove(child: ChildProcessExt): void;
    kill(child: ChildProcess, signal?: 'SIGTERM' | 'SIGKILL'): Promise<void>;
    clean(): Promise<void>;
    getFree(id: string): ChildProcessExt[];
    getAllFree(): ChildProcessExt[];
}

export declare interface ChildProcessExt extends ChildProcess {
    processFile?: string;
}

export declare const clientCommandMessageReg: RegExp;

export declare enum ClientType {
    blocking = "blocking",
    normal = "normal"
}

export declare type ConnectionOptions = RedisOptions | Redis | Cluster;

export declare interface DependenciesOpts {
    processed?: {
        cursor?: number;
        count?: number;
    };
    unprocessed?: {
        cursor?: number;
        count?: number;
    };
}

export declare interface FlowJob {
    name: string;
    queueName: string;
    data?: any;
    prefix?: string;
    opts?: Omit<JobsOptions, 'parent'>;
    children?: FlowJob[];
}

/**
 * This class allows to add jobs with dependencies between them in such
 * a way that it is possible to build complex flows.
 * Note: A flow is a tree-like structure of jobs that depend on each other.
 * Whenever the children of a given parent are completed, the parent
 * will be processed, being able to access the children's result data.
 * All Jobs can be in different queues, either children or parents,
 */
export declare class FlowProducer extends EventEmitter {
    opts: QueueBaseOptions;
    toKey: (name: string, type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    queueKeys: QueueKeys;
    protected connection: RedisConnection;
    constructor(opts?: QueueBaseOptions);
    /**
     * @method add
     * Adds a flow.
     *
     * This call would be atomic, either it fails and no jobs will
     * be added to the queues, or it succeeds and all jobs will be added.
     *
     * @param flow An object with a tree-like structure where children jobs
     * will be processed before their parents.
     */
    add(flow: FlowJob): Promise<JobNode>;
    /**
     * @method getFlow
     * Get a flow.
     *
     * @param opts An object with options for getting a JobNode.
     */
    getFlow(opts: NodeOpts): Promise<JobNode>;
    get client(): Promise<RedisClient>;
    /**
     * Add a node (job) of a flow to the queue. This method will recursively
     * add all its children as well. Note that a given job can potentially be
     * a parent and a child job at the same time depending on where it is located
     * in the tree hierarchy.
     *
     * @param multi ioredis pipeline
     * @param node the node representing a job to be added to some queue
     * @param parent Parent data sent to children to create the "links" to their parent
     * @returns
     */
    private addNode;
    private getNode;
    private addChildren;
    private getChildren;
    /**
     * Helper factory method that creates a queue-like object
     * required to create jobs in any queue.
     *
     * @param node
     * @param queueKeys
     * @returns
     */
    private queueFromNode;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

export declare interface GetNextJobOptions {
    block?: boolean;
}

export declare function getParentKey(opts: {
    id: string;
    queue: string;
}): string;

export declare class Job<T = any, R = any, N extends string = string> {
    private queue;
    /**
     * The name of the Job
     */
    name: N;
    /**
     * The payload for this job.
     */
    data: T;
    /**
     * The options object for this job.
     */
    opts: JobsOptions;
    id?: string;
    /**
     * The progress a job has performed so far.
     */
    progress: number | object;
    /**
     * The value returned by the processor when processing this job.
     */
    returnvalue: R;
    /**
     * Stacktrace for the error (for failed jobs).
     */
    stacktrace: string[];
    /**
     * Timestamp when the job was created (unless overridden with job options).
     */
    timestamp: number;
    /**
     * Number of attempts after the job has failed.
     */
    attemptsMade: number;
    /**
     * Reason for failing.
     */
    failedReason: string;
    /**
     * Timestamp for when the job finished (completed or failed).
     */
    finishedOn?: number;
    /**
     * Timestamp for when the job was processed.
     */
    processedOn?: number;
    /**
     * Fully qualified key (including the queue prefix) pointing to the parent of this job.
     */
    parentKey?: string;
    private toKey;
    private discarded;
    constructor(queue: MinimalQueue, 
    /**
     * The name of the Job
     */
    name: N, 
    /**
     * The payload for this job.
     */
    data: T, 
    /**
     * The options object for this job.
     */
    opts?: JobsOptions, id?: string);
    /**
     * Creates a new job and adds it to the queue.
     *
     * @param queue the queue where to add the job.
     * @param name  the name of the job.
     * @param data  the payload of the job.
     * @param opts the options bag for this job.
     * @returns
     */
    static create<T = any, R = any, N extends string = string>(queue: MinimalQueue, name: N, data: T, opts?: JobsOptions): Promise<Job<T, R, N>>;
    /**
     * Creates a bulk of jobs and adds them atomically to the given queue.
     *
     * @param queue the queue were to add the jobs.
     * @param jobs an array of jobs to be added to the queue.
     * @returns
     */
    static createBulk<T = any, R = any, N extends string = string>(queue: MinimalQueue, jobs: {
        name: N;
        data: T;
        opts?: BulkJobOptions;
    }[]): Promise<Job<T, R, N>[]>;
    /**
     * Instantiates a Job from a JobJsonRaw object (coming from a deserialized JSON object)
     * @param queue the queue where the job belongs to.
     * @param json the plain object containing the job.
     * @param jobId an optional job id (overrides the id coming from the JSON object)
     * @returns
     */
    static fromJSON(queue: MinimalQueue, json: JobJsonRaw, jobId?: string): Job<any, any, string>;
    /**
     * Fetches a Job from the queue given the passed job id.
     *
     * @param queue the queue where the job belongs to.
     * @param jobId the job id.
     * @returns
     */
    static fromId(queue: MinimalQueue, jobId: string): Promise<Job | undefined>;
    toJSON(): Pick<this, Exclude<keyof this, "queue">>;
    /**
     * Prepares a job to be serialized for storage in Redis.
     * @returns
     */
    asJSON(): JobJson;
    /**
     * Updates a job's data
     *
     * @param data the data that will replace the current jobs data.
     */
    update(data: T): Promise<void>;
    updateProgress(progress: number | object): Promise<void>;
    /**
     * Logs one row of log data.
     *
     * @params logRow: string String with log data to be logged.
     *
     */
    log(logRow: string): Promise<number>;
    /**
     * Completely remove the job from the queue.
     * Note, this call will throw an exception if the job
     * is being processed when the call is performed.
     */
    remove(): Promise<void>;
    /**
     * Extend the lock for this job.
     *
     * @param token unique token for the lock
     * @param duration lock duration in milliseconds
     */
    extendLock(token: string, duration: number): Promise<any>;
    /**
     * Moves a job to the completed queue.
     * Returned job to be used with Queue.prototype.nextJobFromJobData.
     * @param returnValue {string} The jobs success message.
     * @param fetchNext {boolean} True when wanting to fetch the next job
     * @returns {Promise} Returns the jobData of the next job in the waiting queue.
     */
    moveToCompleted(returnValue: R, token: string, fetchNext?: boolean): Promise<[JobJsonRaw, string] | []>;
    /**
     * Moves a job to the failed queue.
     * @param err {Error} The jobs error message.
     * @param token {string} Token to check job is locked by current worker
     * @param fetchNext {boolean} True when wanting to fetch the next job
     * @returns void
     */
    moveToFailed(err: Error, token: string, fetchNext?: boolean): Promise<void>;
    /**
     *
     * @returns true if the job has completed.
     */
    isCompleted(): Promise<boolean>;
    /**
     *
     * @returns true if the job has failed.
     */
    isFailed(): Promise<boolean>;
    /**
     *
     * @returns true if the job is delayed.
     */
    isDelayed(): Promise<boolean>;
    /**
     *
     * @returns true if the job is waiting for children.
     */
    isWaitingChildren(): Promise<boolean>;
    /**
     * @method isActive
     *
     * @returns true of the job is active.
     */
    isActive(): Promise<boolean>;
    /**
     *
     * @returns true if the job is waiting.
     */
    isWaiting(): Promise<boolean>;
    get queueName(): string;
    /**
     * @method getState
     * Get current state.
     *
     * @returns {string} Returns one of these values:
     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.
     */
    getState(): Promise<string>;
    /**
     * @method changeDelay
     * Change delay of a delayed job.
     *
     * @returns
     */
    changeDelay(delay: number): Promise<void>;
    /**
     * Get this jobs children result values if any.
     *
     * @returns Object mapping children job keys with their values.
     */
    getChildrenValues<CT = any>(): Promise<{
        [jobKey: string]: CT;
    }>;
    /**
     * @method getDependencies
     * Get children job keys if this job is a parent and has children.
     *
     * @returns dependencies separated by processed and unprocessed.
     */
    getDependencies(opts?: DependenciesOpts): Promise<{
        nextProcessedCursor?: number;
        processed?: Record<string, any>;
        nextUnprocessedCursor?: number;
        unprocessed?: string[];
    }>;
    /**
     * @method getDependenciesCount
     * Get children job counts if this job is a parent and has children.
     *
     * @returns dependencies count separated by processed and unprocessed.
     */
    getDependenciesCount(opts?: {
        processed?: boolean;
        unprocessed?: boolean;
    }): Promise<{
        processed?: number;
        unprocessed?: number;
    }>;
    /**
     * Returns a promise the resolves when the job has finished. (completed or failed).
     */
    waitUntilFinished(queueEvents: QueueEvents, ttl?: number): Promise<R>;
    /**
     * Moves the job to the delay set.
     *
     * @param timestamp timestamp where the job should be moved back to "wait"
     * @returns
     */
    moveToDelayed(timestamp: number): Promise<void>;
    /**
     * Moves the job to the waiting-children set.
     * @param {string} token Token to check job is locked by current worker
     * @param opts the options bag for moving a job to waiting-children.
     * @returns {boolean} true if the job was moved
     */
    moveToWaitingChildren(token: string, opts?: MoveToChildrenOpts): Promise<boolean | Error>;
    /**
     * Promotes a delayed job so that it starts to be processed as soon as possible.
     */
    promote(): Promise<void>;
    /**
     * Attempts to retry the job. Only a job that has failed can be retried.
     *
     * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event
     * otherwise the operation was not a success and throw the corresponding error. If the promise
     * rejects, it indicates that the script failed to execute
     */
    retry(state?: 'completed' | 'failed'): Promise<void>;
    /**
     * Marks a job to not be retried if it fails (even if attempts has been configured)
     */
    discard(): void;
    private isInZSet;
    private isInList;
    /**
     * Adds the job to Redis.
     *
     * @param client
     * @param parentOpts
     * @returns
     */
    addJob(client: RedisClient, parentOpts?: ParentOpts): Promise<string>;
    private saveAttempt;
}

export declare interface JobJson {
    id: string;
    name: string;
    data: string;
    opts: string;
    progress: number | object;
    attemptsMade: number;
    finishedOn?: number;
    processedOn?: number;
    timestamp: number;
    failedReason: string;
    stacktrace: string;
    returnvalue: string;
    parentKey?: string;
}

export declare interface JobJsonRaw {
    id: string;
    name: string;
    data: string;
    opts: string;
    progress: string;
    attemptsMade: string;
    finishedOn?: string;
    processedOn?: string;
    timestamp: string;
    failedReason: string;
    stacktrace: string[];
    returnvalue: string;
    parentKey?: string;
}

export declare interface JobNode {
    job: Job;
    children?: JobNode[];
}

export declare interface JobsOptions {
    /**
     * Timestamp when the job was created. Defaults to `Date.now()`.
     */
    timestamp?: number;
    /**
     * Ranges from 1 (highest priority) to MAX_INT (lowest priority). Note that
     * using priorities has a slight impact on performance,
     * so do not use it if not required.
     */
    priority?: number;
    /**
     * An amount of milliseconds to wait until this job can be processed.
     * Note that for accurate delays, worker and producers
     * should have their clocks synchronized.
     */
    delay?: number;
    /**
     * The total number of attempts to try the job until it completes.
     */
    attempts?: number;
    /**
     * Repeat this job, for example based on a `cron` schedule.
     */
    repeat?: RepeatOptions;
    /**
     * Rate limiter key to use if rate limiter enabled.
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    rateLimiterKey?: string;
    /**
     * Backoff setting for automatic retries if the job fails
     */
    backoff?: number | BackoffOptions;
    /**
     * If true, adds the job to the right of the queue instead of the left (default false)
     *
     * @see {@link https://docs.bullmq.io/guide/jobs/lifo}
     */
    lifo?: boolean;
    /**
     * The number of milliseconds after which the job should be
     * fail with a timeout error.
     */
    timeout?: number;
    /**
     * Override the job ID - by default, the job ID is a unique
     * integer, but you can use this setting to override it.
     * If you use this option, it is up to you to ensure the
     * jobId is unique. If you attempt to add a job with an id that
     * already exists, it will not be added.
     */
    jobId?: string;
    /**
     * If true, removes the job when it successfully completes
     * When given an number, it specifies the maximum amount of
     * jobs to keep.
     * Default behavior is to keep the job in the completed set.
     */
    removeOnComplete?: boolean | number;
    /**
     * If true, removes the job when it fails after all attempts.
     * When given an number, it specifies the maximum amount of
     * jobs to keep.
     */
    removeOnFail?: boolean | number;
    /**
     * Limits the amount of stack trace lines that will be recorded in the stacktrace.
     */
    stackTraceLimit?: number;
    /**
     *
     */
    parent?: {
        id: string;
        queue: string;
    };
    /**
     * Internal property used by repeatable jobs.
     */
    prevMillis?: number;
    /**
     * Limits the size in bytes of the job's data payload (as a JSON serialized string).
     */
    sizeLimit?: number;
}

declare type KeysMap = {
    [index in string]: string;
};

export declare const load: (client: RedisClient) => Promise<void>;

export declare type MinimalQueue = Pick<QueueBase, 'name' | 'client' | 'toKey' | 'keys' | 'opts' | 'closing' | 'waitUntilReady' | 'removeListener' | 'emit' | 'on' | 'redisVersion'>;

export declare interface MoveToChildrenOpts {
    timestamp?: number;
    child?: {
        id: string;
        queue: string;
    };
}

export declare interface NodeOpts {
    queueName: string;
    prefix?: string;
    id: string;
    depth?: number;
    maxChildren?: number;
}

export declare type ParentOpts = {
    waitChildrenKey?: string;
    parentDependenciesKey?: string;
    parentKey?: string;
};

/**
 * An async function that receives `Job`s and handles them.
 */
export declare type Processor<T = any, R = any, N extends string = string> = (job: Job<T, R, N>, token?: string) => Promise<R>;

export declare interface Queue {
    on(event: 'cleaned', listener: (jobs: string[], type: string) => void): this;
    on(event: string, listener: Function): this;
}

export declare class Queue<T = any, R = any, N extends string = string> extends QueueGetters {
    token: string;
    jobsOpts: JobsOptions;
    limiter: {
        groupKey: string;
    };
    private _repeat;
    constructor(name: string, opts?: QueueOptions);
    get defaultJobOptions(): JobsOptions;
    get repeat(): Promise<Repeat>;
    add(name: N, data: T, opts?: JobsOptions): Promise<Job<T, R, N>>;
    private jobIdForGroup;
    /**
     * Adds an array of jobs to the queue.
     * @method add
     * @param jobs: [] The array of jobs to add to the queue. Each job is defined by 3
     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.
     */
    addBulk(jobs: {
        name: N;
        data: T;
        opts?: BulkJobOptions;
    }[]): Promise<Job<T, any, N>[]>;
    /**
      Pauses the processing of this queue globally.
  
      We use an atomic RENAME operation on the wait queue. Since
      we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue
      is renamed to 'paused', no new jobs will be processed (the current ones
      will run until finalized).
  
      Adding jobs requires a LUA script to check first if the paused list exist
      and in that case it will add it there instead of the wait list.
    */
    pause(): Promise<void>;
    resume(): Promise<void>;
    isPaused(): Promise<boolean>;
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    removeRepeatable(name: N, repeatOpts: RepeatOptions, jobId?: string): Promise<any>;
    removeRepeatableByKey(key: string): Promise<any>;
    /**
     * Removes the given job from the queue as well as all its
     * dependencies.
     *
     * @param jobId The if of the job to remove
     * @returns 1 if it managed to remove the job or -1 if the job or
     * any of its dependencies was locked.
     */
    remove(jobId: string): Promise<any>;
    /**
     * Drains the queue, i.e., removes all jobs that are waiting
     * or delayed, but not active, completed or failed.
     *
     * TODO: Convert to an atomic LUA script.
     */
    drain(delayed?: boolean): Promise<[Error, any][]>;
    /**
     * @method clean
     *
     * Cleans jobs from a queue. Similar to drain but keeps jobs within a certain
     * grace period.
     *
     * @param {number} grace - The grace period
     * @param {number} The max number of jobs to clean
     * @param {string} [type=completed] - The type of job to clean
     * Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.
     */
    clean(grace: number, limit: number, type?: 'completed' | 'wait' | 'active' | 'paused' | 'delayed' | 'failed'): Promise<string[]>;
    /**
     * @method obliterate
     *
     * Completely destroys the queue and all of its contents irreversibly.
     * This method will the *pause* the queue and requires that there are no
     * active jobs. It is possible to bypass this requirement, i.e. not
     * having active jobs using the "force" option.
     *
     * Note: This operation requires to iterate on all the jobs stored in the queue
     * and can be slow for very large queues.
     *
     * @param { { force: boolean, count: number }} opts. Use force = true to force obliteration even
     * with active jobs in the queue. Use count with the maximum number of deleted keys per iteration,
     * 1000 is the default.
     */
    obliterate(opts?: {
        force?: boolean;
        count?: number;
    }): Promise<void>;
    trimEvents(maxLength: number): Promise<number>;
}

export declare class QueueBase extends EventEmitter {
    readonly name: string;
    opts: QueueBaseOptions;
    toKey: (type: string) => string;
    keys: KeysMap;
    closing: Promise<void>;
    protected connection: RedisConnection;
    constructor(name: string, opts?: QueueBaseOptions);
    get client(): Promise<RedisClient>;
    get redisVersion(): string;
    waitUntilReady(): Promise<RedisClient>;
    protected base64Name(): string;
    protected clientName(): string;
    close(): Promise<void>;
    disconnect(): Promise<void>;
}

export declare interface QueueBaseOptions {
    connection?: ConnectionOptions;
    /**
     * Prefix for all queue keys.
     */
    prefix?: string;
}

export declare interface QueueEvents {
    on(event: 'active', listener: (args: {
        jobId: string;
        prev?: string;
    }, id: string) => void): this;
    on(event: 'waiting', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'delayed', listener: (args: {
        jobId: string;
        delay: number;
    }, id: string) => void): this;
    on(event: 'progress', listener: (args: {
        jobId: string;
        data: string;
    }, id: string) => void): this;
    on(event: 'stalled', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'completed', listener: (args: {
        jobId: string;
        returnvalue: string;
        prev?: string;
    }, id: string) => void): this;
    on(event: 'failed', listener: (args: {
        jobId: string;
        failedReason: string;
        prev?: string;
    }, id: string) => void): this;
    on(event: 'removed', listener: (args: {
        jobId: string;
    }, id: string) => void): this;
    on(event: 'drained', listener: (id: string) => void): this;
    on(event: string, listener: Function): this;
}

export declare class QueueEvents extends QueueBase {
    constructor(name: string, opts?: QueueEventsOptions);
    private consumeEvents;
    close(): Promise<void>;
}

export declare interface QueueEventsOptions extends QueueBaseOptions {
    lastEventId?: string;
    blockingTimeout?: number;
}

export declare class QueueGetters extends QueueBase {
    getJob(jobId: string): Promise<Job | undefined>;
    private commandByType;
    /**
      Returns the number of jobs waiting to be processed.
    */
    count(): Promise<number>;
    getJobCountByTypes(...types: string[]): Promise<number>;
    /**
     * Returns the job counts for each type specified or every list/set in the queue by default.
     *
     */
    getJobCounts(...types: string[]): Promise<{
        [index: string]: number;
    }>;
    getCompletedCount(): Promise<number>;
    getFailedCount(): Promise<number>;
    getDelayedCount(): Promise<number>;
    getActiveCount(): Promise<number>;
    getWaitingCount(): Promise<number>;
    getWaitingChildrenCount(): Promise<number>;
    getWaiting(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getWaitingChildren(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getActive(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getDelayed(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getCompleted(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getFailed(start?: number, end?: number): Promise<Job<any, any, string>[]>;
    getRanges(types: string[], start?: number, end?: number, asc?: boolean): Promise<any[]>;
    getJobs(types: string[] | string, start?: number, end?: number, asc?: boolean): Promise<Job<any, any, string>[]>;
    getJobLogs(jobId: string, start?: number, end?: number, asc?: boolean): Promise<{
        logs: any;
        count: any;
    }>;
    /**
     * @method getWorkers
     * Get worker list related to the queue.
     *
     * @returns {Object} Returns an array with workers info.
     */
    getWorkers(): Promise<{
        [index: string]: string;
    }[]>;
    private parseClientList;
}

declare class QueueKeys {
    readonly prefix: string;
    constructor(prefix?: string);
    getKeys(name: string): KeysMap;
    toKey(name: string, type: string): string;
    getPrefixedQueueName(name: string): string;
}

export declare interface QueueOptions extends QueueBaseOptions {
    defaultJobOptions?: JobsOptions;
    limiter?: {
        groupKey: string;
    };
    streams?: {
        events: {
            /**
             * Max approximated length for streams
             */
            maxLen: number;
        };
    };
}

export declare interface QueueScheduler {
    on(event: 'stalled', listener: (jobId: string, prev: string) => void): this;
    on(event: 'failed', listener: (jobId: string, failedReason: Error, prev: string) => void): this;
    on(event: string, listener: Function): this;
}

/**
 * This class is just used for some automatic bookkeeping of the queue,
 * such as updating the delay set as well as moving stalled jobs back
 * to the waiting list.
 *
 * Jobs are checked for stallness once every "visibility window" seconds.
 * Jobs are then marked as candidates for being stalled, in the next check,
 * the candidates are marked as stalled and moved to wait.
 * Workers need to clean the candidate list with the jobs that they are working
 * on, failing to update the list results in the job ending being stalled.
 *
 * This class requires a dedicated redis connection, and at least one is needed
 * to be running at a given time, otherwise delays, stalled jobs, retries, repeatable
 * jobs, etc, will not work correctly or at all.
 *
 */
export declare class QueueScheduler extends QueueBase {
    private nextTimestamp;
    private isBlocked;
    private running;
    constructor(name: string, { connection, ...opts }?: QueueSchedulerOptions);
    private run;
    isRunning(): boolean;
    private readDelayedData;
    private updateDelaySet;
    private moveStalledJobsToWait;
    close(): Promise<void>;
}

/**
 * Options for customizing the behaviour of the scheduler.
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/stalled}
 * @see {@link https://docs.bullmq.io/guide/queuescheduler}
 */
export declare interface QueueSchedulerOptions extends QueueBaseOptions {
    /**
     * Amount of times a job can be recovered from a stalled state
     * to the `wait` state. If this is exceeded, the job is moved
     * to `failed`.
     */
    maxStalledCount?: number;
    /**
     * Number of milliseconds between stallness checks.
     */
    stalledInterval?: number;
}

export declare interface RateLimiterOptions {
    /**
     * Max number of jobs to process in the time period
     * specified in `duration`.
     */
    max: number;
    /**
     * Time in milliseconds. During this time, a maximum
     * of `max` jobs will be processed.
     */
    duration: number;
    /**
     * It is possible to define a rate limiter based on group keys,
     * for example you may want to have a rate limiter per customer
     * instead of a global rate limiter for all customers
     *
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    groupKey?: string;
    /**
     * This option enables a heuristic so that when a queue is heavily
     * rete limited, it delays the workers so that they do not try
     * to pick jobs when there is no point in doing so.
     * Note: It is not recommended to use this option when using
     * groupKeys unless you have a big amount of workers since
     * you may be delaying workers that could pick jobs in groups that
     * have not been rate limited.
     */
    workerDelay?: boolean;
}

export declare type RedisClient = Redis | Cluster;

export declare class RedisConnection extends EventEmitter {
    private readonly opts?;
    static minimumVersion: string;
    private _client;
    private initializing;
    private closing;
    private version;
    private handleClientError;
    constructor(opts?: ConnectionOptions);
    /**
     * Waits for a redis client to be ready.
     * @param {Redis} redis client
     */
    static waitUntilReady(client: RedisClient): Promise<void>;
    get client(): Promise<RedisClient>;
    private init;
    disconnect(): Promise<void>;
    reconnect(): Promise<void>;
    close(): Promise<void>;
    private getRedisVersion;
    get redisVersion(): string;
}

export declare type RedisOptions = RedisOptions_2 & {
    skipVersionCheck?: boolean;
};

export declare class Repeat extends QueueBase {
    addNextRepeatableJob<T = any, R = any, N extends string = string>(name: N, data: T, opts: JobsOptions, skipCheckExists?: boolean): Promise<Job<T, R, N>>;
    private createNextJob;
    removeRepeatable(name: string, repeat: RepeatOptions, jobId?: string): Promise<any>;
    removeRepeatableByKey(repeatJobKey: string): Promise<any>;
    private keyToData;
    getRepeatableJobs(start?: number, end?: number, asc?: boolean): Promise<{
        key: string;
        name: string;
        id: string;
        endDate: number;
        tz: string;
        cron: string;
        next: number;
    }[]>;
    getRepeatableCount(): Promise<number>;
}

/**
 * Settings for repeatable jobs
 *
 * @see {@link https://docs.bullmq.io/guide/jobs/repeatable}
 */
export declare interface RepeatOptions {
    /**
     * A cron pattern
     */
    cron?: string;
    /**
     * Timezone
     */
    tz?: string;
    /**
     * Start date when the repeat job should start repeating (only with `cron`).
     */
    startDate?: Date | string | number;
    /**
     * End date when the repeat job should stop repeating.
     */
    endDate?: Date | string | number;
    /**
     * Number of times the job should repeat at max.
     */
    limit?: number;
    /**
     * Repeat after this amount of milliseconds
     * (`cron` setting cannot be used together with this setting.)
     */
    every?: number;
    /**
     * Repeated job should start right now
     * ( work only with every settings)
     */
    immediately?: boolean;
    /**
     * The start value for the repeat iteration count.
     */
    count?: number;
    prevMillis?: number;
    offset?: number;
    jobId?: string;
}

export declare enum RetryErrors {
    JobNotFailed = -2,
    JobIsActive = -1,
    JobNotExist = 0
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare interface SandboxedJob<T = any, R = any> extends Omit<JobJson, 'data' | 'opts' | 'progress' | 'log' | 'returnValue'> {
    data: T;
    opts: JobsOptions;
    progress: (() => object | number) | ((value: object | number) => Promise<void>);
    log: (row: any) => void;
    returnValue: R;
}

/**
 * @see {@link https://docs.bullmq.io/guide/workers/sandboxed-processors}
 */
export declare type SandboxedJobProcessor<T = any, R = any> = ((job: SandboxedJob<T, R>) => R | PromiseLike<R>) | ((job: SandboxedJob<T, R>, callback: (error: unknown, result: R) => void) => void);

export declare class Scripts {
    static isJobInList(queue: MinimalQueue, listKey: string, jobId: string): Promise<boolean>;
    static addJob(client: RedisClient, queue: MinimalQueue, job: JobJson, opts: JobsOptions, jobId: string, parentOpts?: ParentOpts): any;
    static pause(queue: MinimalQueue, pause: boolean): Promise<any>;
    static remove(queue: MinimalQueue, jobId: string): Promise<any>;
    static extendLock(queue: MinimalQueue, jobId: string, token: string, duration: number): Promise<any>;
    static updateProgress(queue: MinimalQueue, job: Job, progress: number | object): Promise<void>;
    static moveToFinishedArgs(queue: MinimalQueue, job: Job, val: any, propVal: string, shouldRemove: boolean | number, target: string, token: string, fetchNext?: boolean): string[];
    static moveToFinished(queue: MinimalQueue, job: Job, val: any, propVal: string, shouldRemove: boolean | number, target: string, token: string, fetchNext: boolean): Promise<[] | [JobJsonRaw, string]>;
    static finishedErrors(code: number, jobId: string, command: string, state: string): Error;
    static moveToCompleted(queue: MinimalQueue, job: Job, returnvalue: any, removeOnComplete: boolean | number, token: string, fetchNext: boolean): Promise<[] | [JobJsonRaw, string]>;
    static moveToFailedArgs(queue: MinimalQueue, job: Job, failedReason: string, removeOnFailed: boolean | number, token: string, fetchNext?: boolean): string[];
    static isFinished(queue: MinimalQueue, jobId: string): Promise<any>;
    static getState(queue: MinimalQueue, jobId: string): Promise<any>;
    static changeDelay(queue: MinimalQueue, jobId: string, delay: number): Promise<void>;
    static changeDelayArgs(queue: MinimalQueue, jobId: string, timestamp: number): string[];
    static moveToDelayedArgs(queue: MinimalQueue, jobId: string, timestamp: number): string[];
    static moveToWaitingChildrenArgs(queue: MinimalQueue, jobId: string, token: string, opts?: MoveToChildrenOpts): string[];
    static moveToDelayed(queue: MinimalQueue, jobId: string, timestamp: number): Promise<void>;
    static moveToWaitingChildren(queue: MinimalQueue, jobId: string, token: string, opts?: MoveToChildrenOpts): Promise<boolean | Error>;
    static cleanJobsInSet(queue: MinimalQueue, set: string, timestamp: number, limit?: number): Promise<any>;
    static retryJobArgs(queue: MinimalQueue, job: Job): string[];
    /**
     * Attempts to reprocess a job
     *
     * @param {Job} job
     * @param {Object} options
     * @param {String} options.state The expected job state. If the job is not found
     * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'
     *
     * @return {Promise<Number>} Returns a promise that evaluates to a return code:
     * 1 means the operation was a success
     * 0 means the job does not exist
     * -1 means the job is currently locked and can't be retried.
     * -2 means the job was not found in the expected set
     */
    static reprocessJob(queue: MinimalQueue, job: Job, state: 'failed' | 'completed'): Promise<any>;
    static moveToActive<T, R, N extends string>(worker: Worker<T, R, N>, token: string, jobId?: string): Promise<[] | [number, undefined] | [JobJsonRaw, string]>;
    static updateDelaySet(queue: MinimalQueue, delayedTimestamp: number): Promise<any>;
    static promote(queue: MinimalQueue, jobId: string): Promise<any>;
    static moveStalledJobsToWait(queue: QueueScheduler): Promise<any>;
    static obliterate(queue: MinimalQueue, opts: {
        force: boolean;
        count: number;
    }): Promise<any>;
}

export declare interface Strategies {
    [index: string]: BackoffFunction;
}

export declare interface Worker {
    on(event: 'active', listener: (job: Job, prev: string) => void): this;
    on(event: 'completed', listener: (job: Job) => void): this;
    on(event: 'drained', listener: () => void): this;
    on(event: 'error', listener: (failedReason: Error) => void): this;
    on(event: 'failed', listener: (job: Job, error: Error) => void): this;
    on(event: 'progress', listener: (job: Job, progress: number | object) => void): this;
    on(event: string, listener: Function): this;
}

export declare class Worker<T = any, R = any, N extends string = string> extends QueueBase {
    opts: WorkerOptions;
    private drained;
    private waiting;
    private running;
    private processFn;
    private resumeWorker;
    private paused;
    private _repeat;
    private childPool;
    private timerManager;
    private blockingConnection;
    private processing;
    constructor(name: string, processor?: string | Processor<T, R, N>, opts?: WorkerOptions);
    waitUntilReady(): Promise<RedisClient>;
    get repeat(): Promise<Repeat>;
    private run;
    /**
     * Returns a promise that resolves to the next job in queue.
     * @param token worker token to be assigned to retrieved job
     * @returns a Job or undefined if no job was available in the queue.
     */
    getNextJob(token: string, { block }?: GetNextJobOptions): Promise<Job<any, any, string>>;
    private moveToActive;
    private waitForJob;
    private nextJobFromJobData;
    processJob(job: Job<T, R, N>, token: string): Promise<void | Job<any, any, string>>;
    /**
     * Pauses the processing of this queue only for this worker.
     */
    pause(doNotWaitActive?: boolean): Promise<void>;
    resume(): void;
    isPaused(): boolean;
    isRunning(): boolean;
    /**
     * Returns a promise that resolves when active jobs are cleared
     *
     * @returns {Promise}
     */
    private whenCurrentJobsFinished;
    close(force?: boolean): Promise<void>;
}

export declare interface WorkerOptions extends QueueBaseOptions {
    /**
     * Amount of jobs that a single worker is allowed to work on
     * in parallel.
     *
     * @see {@link https://docs.bullmq.io/guide/workers/concurrency}
     */
    concurrency?: number;
    /**
     * @see {@link https://docs.bullmq.io/guide/rate-limiting}
     */
    limiter?: RateLimiterOptions;
    skipDelayCheck?: boolean;
    drainDelay?: number;
    lockDuration?: number;
    lockRenewTime?: number;
    settings?: AdvancedOptions;
}

export { }
